module Level3.Problem75
  ( problem
  ) where

import qualified Data.Map as M

import Problem

problem :: Problem Integer
problem =
  Problem
    75
    "Singular integer right triangles"
    (toInteger $ numberOfSingleFormingBelow 1500000)

-- I attemtped a brute force solution taht was incredibly slow, then I looked
-- into if it had anything to do with prime factorization before I simply
-- googled Pythagorean triplets. Thanks Wikipedia!
-- Implementation of Euclid's formula for generating pythagorean triplets
primitivePythagoreanTriplets :: Integer -> [(Integer, Integer, Integer)]
primitivePythagoreanTriplets bound = do
  m <- [1 .. bound]
  n <- filter (\n -> not $ odd n && odd m) $ filter (coprime m) [1 .. m]
  return (2 * m * n, m ^ 2 - n ^ 2, m ^ 2 + n ^ 2)

coprime :: Integer -> Integer -> Bool
coprime = ((== 1) .) . gcd

numberOfSingleFormingBelow :: Integer -> Int
numberOfSingleFormingBelow bound =
  length $ M.filter (== 1) $ allLengthsAndTrianglesFormedBelow bound

allLengthsAndTrianglesFormedBelow :: Num a => Integer -> M.Map Integer a
allLengthsAndTrianglesFormedBelow bound =
  helper $
  map sumTriplet $
  filter ((<= bound) . sumTriplet) $
  -- max value of length of wire generated by the triplet function for a given
  -- bound m is approximately 4*m^2
  primitivePythagoreanTriplets (truncate $ sqrt $ (/ 2) $ fromIntegral bound)
  where
    helper [] = M.empty
    helper (x:xs) = insertAdd (multiplesOfBelow x bound) $ helper xs
    insertAdd [] m = m
    insertAdd (x:xs) m = M.insertWith (+) x 1 $ insertAdd xs m

sumTriplet :: Num a => (a, a, a) -> a
sumTriplet (a, b, c) = a + b + c

multiplesOfBelow :: Integral a => a -> a -> [a]
multiplesOfBelow n bound = map (* n) [1 .. div bound n]
